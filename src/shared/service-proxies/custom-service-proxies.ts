/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const Custom_API_BASE_URL = new InjectionToken<string>('Custom_API_BASE_URL');

@Injectable()
export class MoYuRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(Custom_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateMoYuRecordDto | null | undefined): Observable<MoYuRecordListDto> {
        let url_ = this.baseUrl + "/api/services/cus/MoYuRecord/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MoYuRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MoYuRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MoYuRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MoYuRecordListDto.fromJS(resultData200) : new MoYuRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MoYuRecordListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMoYuRecords(): Observable<MoYuRecordListDto[]> {
        let url_ = this.baseUrl + "/api/services/cus/MoYuRecord/GetMoYuRecords";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMoYuRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMoYuRecords(<any>response_);
                } catch (e) {
                    return <Observable<MoYuRecordListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MoYuRecordListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMoYuRecords(response: HttpResponseBase): Observable<MoYuRecordListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MoYuRecordListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MoYuRecordListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    postStep(input: PostStepInputDto | null | undefined): Observable<MoYuRecordListDto> {
        let url_ = this.baseUrl + "/api/services/cus/MoYuRecord/PostStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostStep(<any>response_);
                } catch (e) {
                    return <Observable<MoYuRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MoYuRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostStep(response: HttpResponseBase): Observable<MoYuRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MoYuRecordListDto.fromJS(resultData200) : new MoYuRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MoYuRecordListDto>(<any>null);
    }
}

@Injectable()
export class WxUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(Custom_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfWxUserListDto> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/GetAll?";
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWxUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWxUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfWxUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWxUserListDto.fromJS(resultData200) : new PagedResultDtoOfWxUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWxUserListDto>(<any>null);
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExport(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/GetExport?";
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: any | null | undefined): Observable<WxUserListDto> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WxUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WxUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WxUserListDto.fromJS(resultData200) : new WxUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UpdateWxUserInput | null | undefined): Observable<WxUserListDto> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WxUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WxUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WxUserListDto.fromJS(resultData200) : new WxUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<WxUserListDto> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WxUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WxUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WxUserListDto.fromJS(resultData200) : new WxUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxUserListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deletes(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/cus/WxUser/Deletes?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class CreateMoYuRecordDto implements ICreateMoYuRecordDto {
    wxUserId: number;
    openId: string;
    imageUrl: string | undefined;
    desc: string | undefined;
    moYuRealTime: moment.Moment | undefined;

    constructor(data?: ICreateMoYuRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wxUserId = data["wxUserId"];
            this.openId = data["openId"];
            this.imageUrl = data["imageUrl"];
            this.desc = data["desc"];
            this.moYuRealTime = data["moYuRealTime"] ? moment(data["moYuRealTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateMoYuRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMoYuRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wxUserId"] = this.wxUserId;
        data["openId"] = this.openId;
        data["imageUrl"] = this.imageUrl;
        data["desc"] = this.desc;
        data["moYuRealTime"] = this.moYuRealTime ? this.moYuRealTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateMoYuRecordDto {
        const json = this.toJSON();
        let result = new CreateMoYuRecordDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMoYuRecordDto {
    wxUserId: number;
    openId: string;
    imageUrl: string | undefined;
    desc: string | undefined;
    moYuRealTime: moment.Moment | undefined;
}

export class MoYuRecordListDto implements IMoYuRecordListDto {
    wxUserId: number | undefined;
    wxUserNickName: string | undefined;
    wxUserAvatarUrl: string | undefined;
    imageUrl: string | undefined;
    desc: string | undefined;
    creationTime: moment.Moment | undefined;
    moYuRealTime: moment.Moment | undefined;
    moYuType: MoYuRecordListDtoMoYuType | undefined;
    integral: number | undefined;
    isWorkTime: boolean | undefined;
    readonly date: string | undefined;
    readonly hour: string | undefined;
    id: number | undefined;

    constructor(data?: IMoYuRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wxUserId = data["wxUserId"];
            this.wxUserNickName = data["wxUserNickName"];
            this.wxUserAvatarUrl = data["wxUserAvatarUrl"];
            this.imageUrl = data["imageUrl"];
            this.desc = data["desc"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.moYuRealTime = data["moYuRealTime"] ? moment(data["moYuRealTime"].toString()) : <any>undefined;
            this.moYuType = data["moYuType"];
            this.integral = data["integral"];
            this.isWorkTime = data["isWorkTime"];
            (<any>this).date = data["date"];
            (<any>this).hour = data["hour"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MoYuRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoYuRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wxUserId"] = this.wxUserId;
        data["wxUserNickName"] = this.wxUserNickName;
        data["wxUserAvatarUrl"] = this.wxUserAvatarUrl;
        data["imageUrl"] = this.imageUrl;
        data["desc"] = this.desc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["moYuRealTime"] = this.moYuRealTime ? this.moYuRealTime.toISOString() : <any>undefined;
        data["moYuType"] = this.moYuType;
        data["integral"] = this.integral;
        data["isWorkTime"] = this.isWorkTime;
        data["date"] = this.date;
        data["hour"] = this.hour;
        data["id"] = this.id;
        return data; 
    }

    clone(): MoYuRecordListDto {
        const json = this.toJSON();
        let result = new MoYuRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IMoYuRecordListDto {
    wxUserId: number | undefined;
    wxUserNickName: string | undefined;
    wxUserAvatarUrl: string | undefined;
    imageUrl: string | undefined;
    desc: string | undefined;
    creationTime: moment.Moment | undefined;
    moYuRealTime: moment.Moment | undefined;
    moYuType: MoYuRecordListDtoMoYuType | undefined;
    integral: number | undefined;
    isWorkTime: boolean | undefined;
    date: string | undefined;
    hour: string | undefined;
    id: number | undefined;
}

export class PostStepInputDto implements IPostStepInputDto {
    wxUserId: number | undefined;
    step: number | undefined;

    constructor(data?: IPostStepInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wxUserId = data["wxUserId"];
            this.step = data["step"];
        }
    }

    static fromJS(data: any): PostStepInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostStepInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wxUserId"] = this.wxUserId;
        data["step"] = this.step;
        return data; 
    }

    clone(): PostStepInputDto {
        const json = this.toJSON();
        let result = new PostStepInputDto();
        result.init(json);
        return result;
    }
}

export interface IPostStepInputDto {
    wxUserId: number | undefined;
    step: number | undefined;
}

export class PagedResultDtoOfWxUserListDto implements IPagedResultDtoOfWxUserListDto {
    totalCount: number | undefined;
    items: WxUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWxUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WxUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWxUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWxUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWxUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWxUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWxUserListDto {
    totalCount: number | undefined;
    items: WxUserListDto[] | undefined;
}

export class WxUserListDto implements IWxUserListDto {
    openId: string | undefined;
    userName: string | undefined;
    nickName: string | undefined;
    avatarUrl: string | undefined;
    readonly moYuCount: number | undefined;
    readonly integral: number | undefined;
    moYuRecords: MoYuRecordListDto[] | undefined;
    id: number | undefined;

    constructor(data?: IWxUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.userName = data["userName"];
            this.nickName = data["nickName"];
            this.avatarUrl = data["avatarUrl"];
            (<any>this).moYuCount = data["moYuCount"];
            (<any>this).integral = data["integral"];
            if (data["moYuRecords"] && data["moYuRecords"].constructor === Array) {
                this.moYuRecords = [] as any;
                for (let item of data["moYuRecords"])
                    this.moYuRecords.push(MoYuRecordListDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WxUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WxUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["userName"] = this.userName;
        data["nickName"] = this.nickName;
        data["avatarUrl"] = this.avatarUrl;
        data["moYuCount"] = this.moYuCount;
        data["integral"] = this.integral;
        if (this.moYuRecords && this.moYuRecords.constructor === Array) {
            data["moYuRecords"] = [];
            for (let item of this.moYuRecords)
                data["moYuRecords"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): WxUserListDto {
        const json = this.toJSON();
        let result = new WxUserListDto();
        result.init(json);
        return result;
    }
}

export interface IWxUserListDto {
    openId: string | undefined;
    userName: string | undefined;
    nickName: string | undefined;
    avatarUrl: string | undefined;
    moYuCount: number | undefined;
    integral: number | undefined;
    moYuRecords: MoYuRecordListDto[] | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class UpdateWxUserInput implements IUpdateWxUserInput {
    id: number | undefined;

    constructor(data?: IUpdateWxUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UpdateWxUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWxUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateWxUserInput {
        const json = this.toJSON();
        let result = new UpdateWxUserInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateWxUserInput {
    id: number | undefined;
}

export enum MoYuRecordListDtoMoYuType {
    _0 = 0, 
    _1 = 1, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}